// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.12.4
// source: cluster.proto

package clusterpb

import (
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type NodeMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Msg:
	//
	//	*NodeMessage_Connect
	//	*NodeMessage_Heartbeat
	Msg           isNodeMessage_Msg `protobuf_oneof:"msg"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeMessage) Reset() {
	*x = NodeMessage{}
	mi := &file_cluster_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeMessage) ProtoMessage() {}

func (x *NodeMessage) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeMessage.ProtoReflect.Descriptor instead.
func (*NodeMessage) Descriptor() ([]byte, []int) {
	return file_cluster_proto_rawDescGZIP(), []int{0}
}

func (x *NodeMessage) GetMsg() isNodeMessage_Msg {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *NodeMessage) GetConnect() *ConnectRequest {
	if x != nil {
		if x, ok := x.Msg.(*NodeMessage_Connect); ok {
			return x.Connect
		}
	}
	return nil
}

func (x *NodeMessage) GetHeartbeat() *HeartbeatRequest {
	if x != nil {
		if x, ok := x.Msg.(*NodeMessage_Heartbeat); ok {
			return x.Heartbeat
		}
	}
	return nil
}

type isNodeMessage_Msg interface {
	isNodeMessage_Msg()
}

type NodeMessage_Connect struct {
	Connect *ConnectRequest `protobuf:"bytes,1,opt,name=connect,proto3,oneof"`
}

type NodeMessage_Heartbeat struct {
	Heartbeat *HeartbeatRequest `protobuf:"bytes,2,opt,name=heartbeat,proto3,oneof"`
}

func (*NodeMessage_Connect) isNodeMessage_Msg() {}

func (*NodeMessage_Heartbeat) isNodeMessage_Msg() {}

type ConnectRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Version       string                 `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"` // binary version e.g. "1.4.0"
	Hostname      string                 `protobuf:"bytes,3,opt,name=hostname,proto3" json:"hostname,omitempty"`
	ConfigHash    uint64                 `protobuf:"varint,4,opt,name=config_hash,json=configHash,proto3" json:"config_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectRequest) Reset() {
	*x = ConnectRequest{}
	mi := &file_cluster_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectRequest) ProtoMessage() {}

func (x *ConnectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectRequest.ProtoReflect.Descriptor instead.
func (*ConnectRequest) Descriptor() ([]byte, []int) {
	return file_cluster_proto_rawDescGZIP(), []int{1}
}

func (x *ConnectRequest) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ConnectRequest) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ConnectRequest) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *ConnectRequest) GetConfigHash() uint64 {
	if x != nil {
		return x.ConfigHash
	}
	return 0
}

type ConfigUpdate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       uint64                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`                         // monotonically increasing
	ConfigYaml    []byte                 `protobuf:"bytes,2,opt,name=config_yaml,json=configYaml,proto3" json:"config_yaml,omitempty"`  // full config YAML (Cluster block stripped)
	ConfigHash    uint64                 `protobuf:"varint,3,opt,name=config_hash,json=configHash,proto3" json:"config_hash,omitempty"` // xxhash64 of config_yaml
	Timestamp     *timestamp.Timestamp   `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Source        string                 `protobuf:"bytes,5,opt,name=source,proto3" json:"source,omitempty"` // "file", "admin-api"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigUpdate) Reset() {
	*x = ConfigUpdate{}
	mi := &file_cluster_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigUpdate) ProtoMessage() {}

func (x *ConfigUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigUpdate.ProtoReflect.Descriptor instead.
func (*ConfigUpdate) Descriptor() ([]byte, []int) {
	return file_cluster_proto_rawDescGZIP(), []int{2}
}

func (x *ConfigUpdate) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ConfigUpdate) GetConfigYaml() []byte {
	if x != nil {
		return x.ConfigYaml
	}
	return nil
}

func (x *ConfigUpdate) GetConfigHash() uint64 {
	if x != nil {
		return x.ConfigHash
	}
	return 0
}

func (x *ConfigUpdate) GetTimestamp() *timestamp.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *ConfigUpdate) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

type HeartbeatRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	ConfigVersion uint64                 `protobuf:"varint,2,opt,name=config_version,json=configVersion,proto3" json:"config_version,omitempty"`
	ConfigHash    uint64                 `protobuf:"varint,3,opt,name=config_hash,json=configHash,proto3" json:"config_hash,omitempty"`
	Status        *NodeStatus            `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	Timestamp     *timestamp.Timestamp   `protobuf:"bytes,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeartbeatRequest) Reset() {
	*x = HeartbeatRequest{}
	mi := &file_cluster_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeartbeatRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeartbeatRequest) ProtoMessage() {}

func (x *HeartbeatRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeartbeatRequest.ProtoReflect.Descriptor instead.
func (*HeartbeatRequest) Descriptor() ([]byte, []int) {
	return file_cluster_proto_rawDescGZIP(), []int{3}
}

func (x *HeartbeatRequest) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *HeartbeatRequest) GetConfigVersion() uint64 {
	if x != nil {
		return x.ConfigVersion
	}
	return 0
}

func (x *HeartbeatRequest) GetConfigHash() uint64 {
	if x != nil {
		return x.ConfigHash
	}
	return 0
}

func (x *HeartbeatRequest) GetStatus() *NodeStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *HeartbeatRequest) GetTimestamp() *timestamp.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

type NodeStatus struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	Routes                int32                  `protobuf:"varint,1,opt,name=routes,proto3" json:"routes,omitempty"`
	HealthyRoutes         int32                  `protobuf:"varint,2,opt,name=healthy_routes,json=healthyRoutes,proto3" json:"healthy_routes,omitempty"`
	ActiveConnections     int32                  `protobuf:"varint,3,opt,name=active_connections,json=activeConnections,proto3" json:"active_connections,omitempty"`
	RunwayVersion         string                 `protobuf:"bytes,4,opt,name=runway_version,json=runwayVersion,proto3" json:"runway_version,omitempty"`
	UptimeSeconds         int64                  `protobuf:"varint,5,opt,name=uptime_seconds,json=uptimeSeconds,proto3" json:"uptime_seconds,omitempty"`
	LastReloadError       string                 `protobuf:"bytes,6,opt,name=last_reload_error,json=lastReloadError,proto3" json:"last_reload_error,omitempty"`                    // empty on success
	LastSuccessfulVersion uint64                 `protobuf:"varint,7,opt,name=last_successful_version,json=lastSuccessfulVersion,proto3" json:"last_successful_version,omitempty"` // last config version applied ok
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *NodeStatus) Reset() {
	*x = NodeStatus{}
	mi := &file_cluster_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeStatus) ProtoMessage() {}

func (x *NodeStatus) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeStatus.ProtoReflect.Descriptor instead.
func (*NodeStatus) Descriptor() ([]byte, []int) {
	return file_cluster_proto_rawDescGZIP(), []int{4}
}

func (x *NodeStatus) GetRoutes() int32 {
	if x != nil {
		return x.Routes
	}
	return 0
}

func (x *NodeStatus) GetHealthyRoutes() int32 {
	if x != nil {
		return x.HealthyRoutes
	}
	return 0
}

func (x *NodeStatus) GetActiveConnections() int32 {
	if x != nil {
		return x.ActiveConnections
	}
	return 0
}

func (x *NodeStatus) GetRunwayVersion() string {
	if x != nil {
		return x.RunwayVersion
	}
	return ""
}

func (x *NodeStatus) GetUptimeSeconds() int64 {
	if x != nil {
		return x.UptimeSeconds
	}
	return 0
}

func (x *NodeStatus) GetLastReloadError() string {
	if x != nil {
		return x.LastReloadError
	}
	return ""
}

func (x *NodeStatus) GetLastSuccessfulVersion() uint64 {
	if x != nil {
		return x.LastSuccessfulVersion
	}
	return 0
}

var File_cluster_proto protoreflect.FileDescriptor

const file_cluster_proto_rawDesc = "" +
	"\n" +
	"\rcluster.proto\x12\x11runway.cluster.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\x98\x01\n" +
	"\vNodeMessage\x12=\n" +
	"\aconnect\x18\x01 \x01(\v2!.runway.cluster.v1.ConnectRequestH\x00R\aconnect\x12C\n" +
	"\theartbeat\x18\x02 \x01(\v2#.runway.cluster.v1.HeartbeatRequestH\x00R\theartbeatB\x05\n" +
	"\x03msg\"\x80\x01\n" +
	"\x0eConnectRequest\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x1a\n" +
	"\bhostname\x18\x03 \x01(\tR\bhostname\x12\x1f\n" +
	"\vconfig_hash\x18\x04 \x01(\x04R\n" +
	"configHash\"\xbc\x01\n" +
	"\fConfigUpdate\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x04R\aversion\x12\x1f\n" +
	"\vconfig_yaml\x18\x02 \x01(\fR\n" +
	"configYaml\x12\x1f\n" +
	"\vconfig_hash\x18\x03 \x01(\x04R\n" +
	"configHash\x128\n" +
	"\ttimestamp\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12\x16\n" +
	"\x06source\x18\x05 \x01(\tR\x06source\"\xe4\x01\n" +
	"\x10HeartbeatRequest\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12%\n" +
	"\x0econfig_version\x18\x02 \x01(\x04R\rconfigVersion\x12\x1f\n" +
	"\vconfig_hash\x18\x03 \x01(\x04R\n" +
	"configHash\x125\n" +
	"\x06status\x18\x04 \x01(\v2\x1d.runway.cluster.v1.NodeStatusR\x06status\x128\n" +
	"\ttimestamp\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\"\xac\x02\n" +
	"\n" +
	"NodeStatus\x12\x16\n" +
	"\x06routes\x18\x01 \x01(\x05R\x06routes\x12%\n" +
	"\x0ehealthy_routes\x18\x02 \x01(\x05R\rhealthyRoutes\x12-\n" +
	"\x12active_connections\x18\x03 \x01(\x05R\x11activeConnections\x12%\n" +
	"\x0erunway_version\x18\x04 \x01(\tR\rrunwayVersion\x12%\n" +
	"\x0euptime_seconds\x18\x05 \x01(\x03R\ruptimeSeconds\x12*\n" +
	"\x11last_reload_error\x18\x06 \x01(\tR\x0flastReloadError\x126\n" +
	"\x17last_successful_version\x18\a \x01(\x04R\x15lastSuccessfulVersion2e\n" +
	"\x0eClusterService\x12S\n" +
	"\fConfigStream\x12\x1e.runway.cluster.v1.NodeMessage\x1a\x1f.runway.cluster.v1.ConfigUpdate(\x010\x01B3Z1github.com/wudi/runway/internal/cluster/clusterpbb\x06proto3"

var (
	file_cluster_proto_rawDescOnce sync.Once
	file_cluster_proto_rawDescData []byte
)

func file_cluster_proto_rawDescGZIP() []byte {
	file_cluster_proto_rawDescOnce.Do(func() {
		file_cluster_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_cluster_proto_rawDesc), len(file_cluster_proto_rawDesc)))
	})
	return file_cluster_proto_rawDescData
}

var file_cluster_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_cluster_proto_goTypes = []any{
	(*NodeMessage)(nil),         // 0: runway.cluster.v1.NodeMessage
	(*ConnectRequest)(nil),      // 1: runway.cluster.v1.ConnectRequest
	(*ConfigUpdate)(nil),        // 2: runway.cluster.v1.ConfigUpdate
	(*HeartbeatRequest)(nil),    // 3: runway.cluster.v1.HeartbeatRequest
	(*NodeStatus)(nil),          // 4: runway.cluster.v1.NodeStatus
	(*timestamp.Timestamp)(nil), // 5: google.protobuf.Timestamp
}
var file_cluster_proto_depIdxs = []int32{
	1, // 0: runway.cluster.v1.NodeMessage.connect:type_name -> runway.cluster.v1.ConnectRequest
	3, // 1: runway.cluster.v1.NodeMessage.heartbeat:type_name -> runway.cluster.v1.HeartbeatRequest
	5, // 2: runway.cluster.v1.ConfigUpdate.timestamp:type_name -> google.protobuf.Timestamp
	4, // 3: runway.cluster.v1.HeartbeatRequest.status:type_name -> runway.cluster.v1.NodeStatus
	5, // 4: runway.cluster.v1.HeartbeatRequest.timestamp:type_name -> google.protobuf.Timestamp
	0, // 5: runway.cluster.v1.ClusterService.ConfigStream:input_type -> runway.cluster.v1.NodeMessage
	2, // 6: runway.cluster.v1.ClusterService.ConfigStream:output_type -> runway.cluster.v1.ConfigUpdate
	6, // [6:7] is the sub-list for method output_type
	5, // [5:6] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_cluster_proto_init() }
func file_cluster_proto_init() {
	if File_cluster_proto != nil {
		return
	}
	file_cluster_proto_msgTypes[0].OneofWrappers = []any{
		(*NodeMessage_Connect)(nil),
		(*NodeMessage_Heartbeat)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_cluster_proto_rawDesc), len(file_cluster_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_cluster_proto_goTypes,
		DependencyIndexes: file_cluster_proto_depIdxs,
		MessageInfos:      file_cluster_proto_msgTypes,
	}.Build()
	File_cluster_proto = out.File
	file_cluster_proto_goTypes = nil
	file_cluster_proto_depIdxs = nil
}
