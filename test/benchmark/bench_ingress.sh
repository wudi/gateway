#!/usr/bin/env bash
# bench_ingress.sh — Benchmark: Gateway Ingress Controller vs Traefik on k3s
#
# Prerequisites:
#   - k3s running with Traefik enabled (default)
#   - kubectl, wrk, ab installed
#   - Go toolchain available (builds the gateway binary)
#
# Usage:
#   ./test/benchmark/bench_ingress.sh
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# ---------- tunables ----------
NAMESPACE="bench"
GW_HTTP_PORT=9080
GW_ADMIN_PORT=9081
GW_METRICS_PORT=9091
WRK_THREADS=3
WRK_DURATION=15
WRK_WARMUP=3
AB_REQUESTS_BASE=5000   # multiplied by concurrency
CONCURRENCY_LEVELS=(1 10 50 100 200)
SCENARIOS=("small-keepalive" "large-keepalive" "small-no-keepalive" "large-no-keepalive")
TRAEFIK_HOST="bench.traefik.local"
GATEWAY_HOST="bench.gateway.local"
TRAEFIK_PORT=80
RESULTS_DIR=""
GW_PID=""
GW_BINARY=""

# ---------- colours ----------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

log()  { echo -e "${CYAN}[bench]${NC} $*"; }
warn() { echo -e "${YELLOW}[warn]${NC} $*"; }
err()  { echo -e "${RED}[error]${NC} $*" >&2; }
ok()   { echo -e "${GREEN}[ok]${NC} $*"; }

# ---------- cleanup ----------
cleanup() {
    log "Cleaning up..."
    if [[ -n "$GW_PID" ]] && kill -0 "$GW_PID" 2>/dev/null; then
        kill "$GW_PID" 2>/dev/null || true
        wait "$GW_PID" 2>/dev/null || true
        log "Stopped gateway process (PID $GW_PID)"
    fi
    kubectl delete namespace "$NAMESPACE" --ignore-not-found --wait=false 2>/dev/null || true
    kubectl delete ingressclass gateway --ignore-not-found 2>/dev/null || true
    if [[ -n "$GW_BINARY" ]] && [[ -f "$GW_BINARY" ]]; then
        rm -f "$GW_BINARY"
    fi
    log "Cleanup complete"
}
trap cleanup EXIT

# ---------- preflight ----------
phase_preflight() {
    log "Checking prerequisites..."
    local missing=()
    for cmd in kubectl go wrk ab; do
        if ! command -v "$cmd" &>/dev/null; then
            missing+=("$cmd")
        fi
    done
    if [[ ${#missing[@]} -gt 0 ]]; then
        err "Missing required commands: ${missing[*]}"
        exit 1
    fi

    if ! kubectl cluster-info &>/dev/null; then
        err "kubectl cannot reach cluster"
        exit 1
    fi

    # Verify Traefik is running
    if ! kubectl get svc -n kube-system traefik &>/dev/null; then
        err "Traefik service not found in kube-system namespace"
        exit 1
    fi

    RESULTS_DIR=$(mktemp -d "/tmp/bench-ingress-XXXXXX")
    log "Results directory: $RESULTS_DIR"
    ok "Prerequisites satisfied"
}

# ---------- build ----------
phase_build() {
    log "Building gateway ingress controller..."
    GW_BINARY=$(mktemp /tmp/gateway-ingress-XXXXXX)
    (cd "$REPO_ROOT" && go build -o "$GW_BINARY" ./cmd/ingress/)
    chmod +x "$GW_BINARY"
    ok "Built $GW_BINARY"
}

# ---------- deploy backend ----------
phase_deploy() {
    log "Deploying echo backend in namespace '$NAMESPACE'..."

    kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

    # nginx ConfigMap with echo endpoints
    # /large serves a static 10KB file generated by an init container
    cat <<'YAML_END' | sed "s/\$NAMESPACE/$NAMESPACE/g" | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: echo-nginx-conf
  namespace: $NAMESPACE
data:
  default.conf: |
    server {
        listen 80;
        server_name _;

        location /small {
            default_type application/json;
            return 200 '{"status":"ok","host":"$hostname","ts":"$msec"}';
        }

        location /large {
            alias /usr/share/nginx/html/;
            try_files /large.json =404;
            default_type application/json;
        }

        location /health {
            default_type text/plain;
            return 200 'ok';
        }

        location / {
            default_type text/plain;
            return 200 'echo backend';
        }
    }
YAML_END

    # Deployment: 2 replicas with init container to generate large.json
    cat <<'YAML_END' | sed "s/\$NAMESPACE/$NAMESPACE/g" | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: echo
  namespace: $NAMESPACE
spec:
  replicas: 2
  selector:
    matchLabels:
      app: echo
  template:
    metadata:
      labels:
        app: echo
    spec:
      initContainers:
        - name: gen-large
          image: nginx:1.27-alpine
          command: ["sh", "-c"]
          args:
            - |
              PAD=$(dd if=/dev/zero bs=1 count=9800 2>/dev/null | tr '\0' 'x')
              printf '{"status":"ok","padding":"%s"}\n' "$PAD" > /data/large.json
          volumeMounts:
            - name: html
              mountPath: /data
      containers:
        - name: nginx
          image: nginx:1.27-alpine
          ports:
            - containerPort: 80
          readinessProbe:
            httpGet:
              path: /health
              port: 80
            initialDelaySeconds: 2
            periodSeconds: 3
          volumeMounts:
            - name: conf
              mountPath: /etc/nginx/conf.d
            - name: html
              mountPath: /usr/share/nginx/html
      volumes:
        - name: conf
          configMap:
            name: echo-nginx-conf
        - name: html
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: echo
  namespace: $NAMESPACE
spec:
  selector:
    app: echo
  ports:
    - port: 80
      targetPort: 80
YAML_END

    # Wait for pods to be ready
    log "Waiting for echo pods to be ready..."
    kubectl rollout status deployment/echo -n "$NAMESPACE" --timeout=300s

    # Ingress for Traefik
    cat <<YAML | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: bench-traefik
  namespace: $NAMESPACE
spec:
  ingressClassName: traefik
  rules:
    - host: $TRAEFIK_HOST
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: echo
                port:
                  number: 80
YAML

    # Ingress for Gateway
    cat <<YAML | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: bench-gateway
  namespace: $NAMESPACE
spec:
  ingressClassName: gateway
  rules:
    - host: $GATEWAY_HOST
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: echo
                port:
                  number: 80
YAML

    ok "Backend and Ingress resources deployed"
}

# ---------- start gateway ----------
phase_start_gw() {
    # Kill any leftover gateway processes on our ports
    local stale_pid
    stale_pid=$(ss -tlnp 2>/dev/null | grep ":${GW_HTTP_PORT} " | grep -oP 'pid=\K[0-9]+' || true)
    if [[ -n "$stale_pid" ]]; then
        kill -9 "$stale_pid" 2>/dev/null || true
        sleep 1
    fi

    log "Creating IngressClass 'gateway'..."
    cat <<YAML | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: gateway
spec:
  controller: apigw.dev/ingress-controller
YAML

    # Ensure KUBECONFIG is set (k3s stores config at a non-standard path)
    if [[ -z "${KUBECONFIG:-}" ]]; then
        if [[ -f /etc/rancher/k3s/k3s.yaml ]]; then
            export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
        fi
    fi

    log "Starting gateway ingress controller on port $GW_HTTP_PORT..."
    "$GW_BINARY" \
        --ingress-class=gateway \
        --http-port="$GW_HTTP_PORT" \
        --admin-port="$GW_ADMIN_PORT" \
        --metrics-port="$GW_METRICS_PORT" \
        --publish-status-address=127.0.0.1 \
        --enable-gateway-api=false \
        --leader-election-namespace="$NAMESPACE" \
        > "$RESULTS_DIR/gateway.log" 2>&1 &
    GW_PID=$!
    log "Gateway PID: $GW_PID"

    # Wait for gateway to become ready
    log "Waiting for gateway to be ready..."
    local retries=0
    local max_retries=30
    while [[ $retries -lt $max_retries ]]; do
        if curl -sf "http://127.0.0.1:$GW_ADMIN_PORT/health" &>/dev/null; then
            ok "Gateway is ready"
            return 0
        fi
        if ! kill -0 "$GW_PID" 2>/dev/null; then
            err "Gateway process exited unexpectedly. Log:"
            tail -20 "$RESULTS_DIR/gateway.log"
            exit 1
        fi
        retries=$((retries + 1))
        sleep 1
    done
    err "Gateway did not become ready within ${max_retries}s. Log:"
    tail -20 "$RESULTS_DIR/gateway.log"
    exit 1
}

# ---------- verify ----------
phase_verify() {
    log "Verifying both controllers serve traffic..."

    local failed=0

    # Verify Traefik
    for path in /small /large; do
        local code
        code=$(curl -sf -o /dev/null -w '%{http_code}' -H "Host: $TRAEFIK_HOST" "http://127.0.0.1:${TRAEFIK_PORT}${path}" 2>/dev/null || echo "000")
        if [[ "$code" == "200" ]]; then
            ok "Traefik ${path} → $code"
        else
            err "Traefik ${path} → $code (expected 200)"
            failed=1
        fi
    done

    # Verify Gateway
    for path in /small /large; do
        local code
        code=$(curl -sf -o /dev/null -w '%{http_code}' -H "Host: $GATEWAY_HOST" "http://127.0.0.1:${GW_HTTP_PORT}${path}" 2>/dev/null || echo "000")
        if [[ "$code" == "200" ]]; then
            ok "Gateway ${path} → $code"
        else
            err "Gateway ${path} → $code (expected 200)"
            failed=1
        fi
    done

    if [[ $failed -ne 0 ]]; then
        err "Verification failed — aborting benchmark"
        exit 1
    fi
    ok "Both controllers verified"
}

# ---------- benchmark helpers ----------

# run_wrk <host> <port> <path> <concurrency> <output_file>
run_wrk() {
    local host=$1 port=$2 path=$3 conc=$4 outfile=$5
    # wrk requires connections >= threads
    local threads=$WRK_THREADS
    [[ $conc -lt $threads ]] && threads=$conc

    # warmup (discard output)
    wrk -t"$threads" -c"$conc" -d"${WRK_WARMUP}s" --timeout 5s \
        -H "Host: $host" "http://127.0.0.1:${port}${path}" >/dev/null 2>&1 || true

    # actual measurement
    wrk -t"$threads" -c"$conc" -d"${WRK_DURATION}s" --latency --timeout 5s \
        -H "Host: $host" "http://127.0.0.1:${port}${path}" > "$outfile" 2>&1
}

# run_ab <host> <port> <path> <concurrency> <output_file>
run_ab() {
    local host=$1 port=$2 path=$3 conc=$4 outfile=$5
    local nreqs=$((AB_REQUESTS_BASE * conc))
    # minimum 1000 requests
    [[ $nreqs -lt 1000 ]] && nreqs=1000

    ab -n "$nreqs" -c "$conc" \
        -H "Host: $host" \
        "http://127.0.0.1:${port}${path}" > "$outfile" 2>&1 || true
}

# parse_wrk <output_file> — prints: rps avg_lat p50 p99 errors
parse_wrk() {
    local f=$1
    local rps avg_lat p50 p99 errors

    rps=$(grep 'Requests/sec:' "$f" | awk '{print $2}' || echo "0")
    avg_lat=$(grep '^\s*Latency' "$f" | head -1 | awk '{print $2}' || echo "0")
    p50=$(grep '^\s*50%' "$f" | awk '{print $2}' || echo "0")
    p99=$(grep '^\s*99%' "$f" | awk '{print $2}' || echo "0")
    errors=$(grep 'Non-2xx' "$f" | awk '{print $NF}' || echo "0")
    [[ -z "$errors" ]] && errors="0"

    echo "$rps $avg_lat $p50 $p99 $errors"
}

# parse_ab <output_file> — prints: rps avg_lat p50 p99 errors
parse_ab() {
    local f=$1
    local rps p50 p99 errors avg_lat

    rps=$(grep 'Requests per second:' "$f" | awk '{print $4}' || echo "0")
    avg_lat=$(grep 'Time per request:.*\(mean\)' "$f" | head -1 | awk '{print $4}' || echo "0")
    p50=$(grep '^\s*50%' "$f" | awk '{print $2}' || echo "0")
    p99=$(grep '^\s*99%' "$f" | awk '{print $2}' || echo "0")
    errors=$(grep 'Failed requests:' "$f" | awk '{print $3}' || echo "0")
    [[ -z "$errors" ]] && errors="0"

    echo "$rps ${avg_lat}ms ${p50}ms ${p99}ms $errors"
}

# wait_gw_healthy — wait for gateway backends to be healthy (up to 30s)
wait_gw_healthy() {
    local retries=0
    while [[ $retries -lt 30 ]]; do
        local healthy
        healthy=$(curl -sf "http://127.0.0.1:${GW_ADMIN_PORT}/health" 2>/dev/null | \
            grep -o '"healthy_routes":[0-9]*' | grep -o '[0-9]*' || echo "0")
        if [[ "$healthy" -gt 0 ]]; then
            return 0
        fi
        retries=$((retries + 1))
        sleep 1
    done
    warn "Gateway backends not healthy after 30s"
}

# ---------- benchmark ----------
phase_benchmark() {
    log "Starting benchmark matrix..."
    log "Concurrency levels: ${CONCURRENCY_LEVELS[*]}"
    log "Each wrk test: ${WRK_WARMUP}s warmup + ${WRK_DURATION}s measurement"

    local test_num=0
    local total_tests=$(( ${#SCENARIOS[@]} * ${#CONCURRENCY_LEVELS[@]} * 2 ))

    for scenario in "${SCENARIOS[@]}"; do
        local path tool
        case "$scenario" in
            small-keepalive)     path="/small"; tool="wrk" ;;
            large-keepalive)     path="/large"; tool="wrk" ;;
            small-no-keepalive)  path="/small"; tool="ab" ;;
            large-no-keepalive)  path="/large"; tool="ab" ;;
        esac

        for conc in "${CONCURRENCY_LEVELS[@]}"; do
            # Traefik
            test_num=$((test_num + 1))
            log "[$test_num/$total_tests] $scenario c=$conc traefik ($tool)"
            local tfile="$RESULTS_DIR/traefik_${scenario}_c${conc}.txt"
            if [[ "$tool" == "wrk" ]]; then
                run_wrk "$TRAEFIK_HOST" "$TRAEFIK_PORT" "$path" "$conc" "$tfile"
            else
                run_ab "$TRAEFIK_HOST" "$TRAEFIK_PORT" "$path" "$conc" "$tfile"
            fi

            # Gateway — ensure backends are healthy before testing
            wait_gw_healthy
            test_num=$((test_num + 1))
            log "[$test_num/$total_tests] $scenario c=$conc gateway ($tool)"
            local gfile="$RESULTS_DIR/gateway_${scenario}_c${conc}.txt"
            if [[ "$tool" == "wrk" ]]; then
                run_wrk "$GATEWAY_HOST" "$GW_HTTP_PORT" "$path" "$conc" "$gfile"
            else
                run_ab "$GATEWAY_HOST" "$GW_HTTP_PORT" "$path" "$conc" "$gfile"
            fi
        done
    done

    ok "Benchmark complete ($total_tests tests)"
}

# ---------- report ----------

# format_latency normalises wrk latency values (e.g. 1.23ms, 500.00us) to ms string
format_latency() {
    local val="$1"
    if [[ "$val" == *us ]]; then
        local num="${val%us}"
        printf "%.2fms" "$(echo "$num / 1000" | bc -l 2>/dev/null || echo "0")"
    elif [[ "$val" == *ms ]]; then
        echo "$val"
    elif [[ "$val" == *s ]]; then
        local num="${val%s}"
        printf "%.0fms" "$(echo "$num * 1000" | bc -l 2>/dev/null || echo "0")"
    else
        echo "${val}"
    fi
}

# strip_ms removes the ms suffix and returns a float
strip_ms() {
    local val="$1"
    val="${val%ms}"
    echo "$val"
}

# calc_delta <traefik_rps> <gateway_rps> — prints delta string like "+13%" or "-5%"
calc_delta() {
    local t_rps=$1 g_rps=$2
    if [[ "$t_rps" == "0" ]] || [[ -z "$t_rps" ]]; then
        echo "N/A"
        return
    fi
    local pct
    pct=$(awk "BEGIN { printf \"%.0f\", (($g_rps - $t_rps) / $t_rps) * 100 }" 2>/dev/null || echo "0")
    if [[ $pct -ge 0 ]]; then
        echo "+${pct}%"
    else
        echo "${pct}%"
    fi
}

phase_report() {
    echo ""
    echo "================================================================================"
    echo "       Gateway vs Traefik Ingress Benchmark — k3s ($(nproc) CPU, $(free -h | awk '/Mem:/{print $2}') RAM)"
    echo "================================================================================"

    # Collect summary data for final table
    declare -A SUMMARY

    for scenario in "${SCENARIOS[@]}"; do
        local tool label
        case "$scenario" in
            small-keepalive)     tool="wrk"; label="Small Response (~100B) — Keep-Alive (wrk, ${WRK_DURATION}s, ${WRK_THREADS} threads)" ;;
            large-keepalive)     tool="wrk"; label="Large Response (~10KB) — Keep-Alive (wrk, ${WRK_DURATION}s, ${WRK_THREADS} threads)" ;;
            small-no-keepalive)  tool="ab";  label="Small Response (~100B) — No Keep-Alive (ab)" ;;
            large-no-keepalive)  tool="ab";  label="Large Response (~10KB) — No Keep-Alive (ab)" ;;
        esac

        echo ""
        echo -e "${BOLD}>>> ${label}${NC}"
        echo ""
        printf "  %-6s | %13s | %13s | %13s | %13s | %7s\n" \
            "Conc" "Traefik RPS" "Gateway RPS" "Traefik P99" "Gateway P99" "Δ RPS"
        printf "  -------+---------------+---------------+---------------+---------------+--------\n"

        for conc in "${CONCURRENCY_LEVELS[@]}"; do
            local tfile="$RESULTS_DIR/traefik_${scenario}_c${conc}.txt"
            local gfile="$RESULTS_DIR/gateway_${scenario}_c${conc}.txt"

            local t_parsed g_parsed
            if [[ "$tool" == "wrk" ]]; then
                t_parsed=$(parse_wrk "$tfile")
                g_parsed=$(parse_wrk "$gfile")
            else
                t_parsed=$(parse_ab "$tfile")
                g_parsed=$(parse_ab "$gfile")
            fi

            local t_rps t_avg t_p50 t_p99 t_err
            read -r t_rps t_avg t_p50 t_p99 t_err <<< "$t_parsed"
            local g_rps g_avg g_p50 g_p99 g_err
            read -r g_rps g_avg g_p50 g_p99 g_err <<< "$g_parsed"

            # Format latencies for wrk results
            if [[ "$tool" == "wrk" ]]; then
                t_p99=$(format_latency "$t_p99")
                g_p99=$(format_latency "$g_p99")
            fi

            local delta
            delta=$(calc_delta "$t_rps" "$g_rps")
            SUMMARY["${scenario}_${conc}"]="$delta"

            # Format RPS to integer for display
            local t_rps_int g_rps_int
            t_rps_int=$(printf "%.0f" "$t_rps" 2>/dev/null || echo "$t_rps")
            g_rps_int=$(printf "%.0f" "$g_rps" 2>/dev/null || echo "$g_rps")

            printf "  %6d | %13s | %13s | %13s | %13s | %7s\n" \
                "$conc" "$t_rps_int" "$g_rps_int" "$t_p99" "$g_p99" "$delta"

            # Print errors if any
            if [[ "$t_err" != "0" ]] && [[ -n "$t_err" ]]; then
                warn "  Traefik errors: $t_err"
            fi
            if [[ "$g_err" != "0" ]] && [[ -n "$g_err" ]]; then
                warn "  Gateway errors: $g_err"
            fi
        done
    done

    # Summary table
    echo ""
    echo -e "${BOLD}>>> Summary — Relative Performance (positive = Gateway faster)${NC}"
    echo ""
    printf "  %-20s" "Scenario"
    for conc in "${CONCURRENCY_LEVELS[@]}"; do
        printf " | %7s" "c=$conc"
    done
    echo ""
    printf -- "  --------------------"
    for _ in "${CONCURRENCY_LEVELS[@]}"; do
        printf -- "-+---------"
    done
    echo ""

    for scenario in "${SCENARIOS[@]}"; do
        printf "  %-20s" "$scenario"
        for conc in "${CONCURRENCY_LEVELS[@]}"; do
            local key="${scenario}_${conc}"
            printf " | %7s" "${SUMMARY[$key]:-N/A}"
        done
        echo ""
    done

    echo "================================================================================"
    echo ""
    log "Raw results saved in: $RESULTS_DIR"
}

# ---------- main ----------
main() {
    echo -e "${BOLD}Gateway vs Traefik Ingress Controller Benchmark${NC}"
    echo ""

    phase_preflight
    phase_build
    phase_deploy
    phase_start_gw
    phase_verify
    phase_benchmark
    phase_report
}

main "$@"
